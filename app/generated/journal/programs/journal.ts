/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  parseCreateJournalEntryInstruction,
  parseDeleteJournalEntryInstruction,
  parseInitializeCounterInstruction,
  parseUpdateJournalEntryInstruction,
  type ParsedCreateJournalEntryInstruction,
  type ParsedDeleteJournalEntryInstruction,
  type ParsedInitializeCounterInstruction,
  type ParsedUpdateJournalEntryInstruction,
} from "../instructions/index.ts";

export const JOURNAL_PROGRAM_ADDRESS =
  "91be9qkpnxDk6vrFc1fpxz7pxB3Ec5aAhgVussaw1VSj" as Address<"91be9qkpnxDk6vrFc1fpxz7pxB3Ec5aAhgVussaw1VSj">;

export const JournalAccount = {
  JournalEntryCounterState: 0,
  JournalEntryState: 1,
} as const;
export type JournalAccount = (typeof JournalAccount)[keyof typeof JournalAccount];

export function identifyJournalAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): JournalAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([58, 246, 228, 197, 232, 120, 203, 129]),
      ),
      0,
    )
  ) {
    return JournalAccount.JournalEntryCounterState;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([113, 86, 110, 124, 140, 14, 58, 66]),
      ),
      0,
    )
  ) {
    return JournalAccount.JournalEntryState;
  }
  throw new Error(
    "The provided account could not be identified as a journal account.",
  );
}

export const JournalInstruction = {
  CreateJournalEntry: 0,
  DeleteJournalEntry: 1,
  InitializeCounter: 2,
  UpdateJournalEntry: 3,
} as const;
export type JournalInstruction = (typeof JournalInstruction)[keyof typeof JournalInstruction];

export function identifyJournalInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): JournalInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([48, 65, 201, 186, 25, 41, 127, 0]),
      ),
      0,
    )
  ) {
    return JournalInstruction.CreateJournalEntry;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([156, 50, 93, 5, 157, 97, 188, 114]),
      ),
      0,
    )
  ) {
    return JournalInstruction.DeleteJournalEntry;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([67, 89, 100, 87, 231, 172, 35, 124]),
      ),
      0,
    )
  ) {
    return JournalInstruction.InitializeCounter;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([113, 164, 49, 62, 43, 83, 194, 172]),
      ),
      0,
    )
  ) {
    return JournalInstruction.UpdateJournalEntry;
  }
  throw new Error(
    "The provided instruction could not be identified as a journal instruction.",
  );
}

export type ParsedJournalInstruction<
  TProgram extends string = "91be9qkpnxDk6vrFc1fpxz7pxB3Ec5aAhgVussaw1VSj",
> =
  | ({
      instructionType: (typeof JournalInstruction)["CreateJournalEntry"];
    } & ParsedCreateJournalEntryInstruction<TProgram>)
  | ({
      instructionType: (typeof JournalInstruction)["DeleteJournalEntry"];
    } & ParsedDeleteJournalEntryInstruction<TProgram>)
  | ({
      instructionType: (typeof JournalInstruction)["InitializeCounter"];
    } & ParsedInitializeCounterInstruction<TProgram>)
  | ({
      instructionType: (typeof JournalInstruction)["UpdateJournalEntry"];
    } & ParsedUpdateJournalEntryInstruction<TProgram>);

export function parseJournalInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedJournalInstruction<TProgram> {
  const instructionType = identifyJournalInstruction(instruction);
  switch (instructionType) {
    case JournalInstruction.CreateJournalEntry: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: JournalInstruction.CreateJournalEntry,
        ...parseCreateJournalEntryInstruction(instruction),
      };
    }
    case JournalInstruction.DeleteJournalEntry: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: JournalInstruction.DeleteJournalEntry,
        ...parseDeleteJournalEntryInstruction(instruction),
      };
    }
    case JournalInstruction.InitializeCounter: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: JournalInstruction.InitializeCounter,
        ...parseInitializeCounterInstruction(instruction),
      };
    }
    case JournalInstruction.UpdateJournalEntry: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: JournalInstruction.UpdateJournalEntry,
        ...parseUpdateJournalEntryInstruction(instruction),
      };
    }
    default:
      throw new Error(
        `Unrecognized instruction type: ${instructionType as string}`,
      );
  }
}
